// cmdlib/opt.go
// Copyright 2019 Brian Fitzgerald <neurocline@gmail.com>
//
// Simple command-line parser with auto-usage.

package cmdlib

import (
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
	"time"
	"unsafe"
)

// TODO:
// - add help text and help output
// - add IntSliceArg, others
// - support "pause parsing" note in callback (overlap with stop on unknown)
// - support responsefiles (@<cmdfile> that contains commands inserted in place)
// NOTE:
// - don't get carried away, design model is primitives calling code can compose

// Parser creates a new command-line parser
func Parser(name string, args []string) *CmdParser {
	return &CmdParser{name: name, u: NewCommandUsage(), args: args}
}

type CmdParser struct {
	args []string // args to be parsed
	pos  int      // next arg to parse
	arg  string   // next arg

	name string // name of the program
	u    *CommandUsage
}

// (*CmdParser).Parse processes a command-line, passing each
// parsed argument to the user callback for disposition. We
// gather usage information to show in the case of an error.
// TBD make this return error instead of halting on its own.
func (p *CmdParser) Parse(user func() bool) {

	remain := p.ParsePartial(user)
	if remain < len(p.args) {
		fmt.Printf("unknown option: '%s'\n", p.args[remain])
		p.Usage(1)
	}
}

// (*CmdParser).ParsePartial processes a command-line, stopping at
// the first unknown argument, and returning the number of arguments
// successfully parsed.
func (p *CmdParser) ParsePartial(user func() bool) int {

	// Force usage to be generated by looking for an unknown command
	// (it's impossible for an argument to be a space character)
	p.BoolArg(" ", nil)

	// Run through all the arguments and call the user function to
	// assign values to parameters
	//p.pos = 0
	for p.pos < len(p.args) {
		p.arg = p.args[p.pos]
		p.pos += 1

		if !user() {
			p.pos = p.pos - 1
			break
		}
	}

	return p.pos
}

// (*CmdParser).Usage shows command-line usage and exits with the
// user-specified return code (pass 0 to exit normally).
func (p *CmdParser) Usage(fail int) {
	fmt.Fprintf(os.Stderr, "%s\n", p.u.Usage(fmt.Sprintf("usage: %s", p.name)))
	os.Exit(fail)
}

// ----------------------------------------------------------------------------------------------

func (p *CmdParser) Arg(opt string, tag string, val interface{}) bool {

	switch v := val.(type) {
		case *bool:
			return p.BoolArg(opt, v)
		case *string:
			return p.StrArg(opt, v, tag)
		case *[]string:
			return p.StrListArg(opt, v, tag)
		case *int:
			return p.IntArg(opt, v, tag)
	}

	// Error if we get this far. This should make it a compile-time error.
	log.Fatalf("Unsupported type for opt=%s: %T", opt, val)
	return false
}

// ----------------------------------------------------------------------------------------------

// BoolArg auto-creates usage and checks the current arg against a
// specific boolean option.
func (p *CmdParser) BoolArg(opt string, val *bool) bool {
	p.u.MakeUsage(opt, "bool", uintptr(unsafe.Pointer(val)))

	if p.arg != opt {
		return false
	}

	*val = true
	return true
}

// StrArg auto-creates usage and checks the current arg against a
// specific string option. Both "--opt=val" and "--opt val" forms are allowed.
func (p *CmdParser) StrArg(opt string, val *string, tag string) bool {
	p.u.MakeUsage(opt, tag, uintptr(unsafe.Pointer(val)))

	// If this is not an option, then it's a positional argument.
	// Single-value positional arguments can only be stored into once.
	if opt[0] != '-' && p.arg[0] != '-' {
		if p.u.WasSeen(uintptr(unsafe.Pointer(val))) {
			return false
		}
		*val = p.arg
		p.u.Seen(uintptr(unsafe.Pointer(val)))
		return true
	}

	// If this is of the form --opt=val, then get the value from arg
	optlen := len(opt)
	if len(p.arg) > optlen && p.arg[:optlen] == opt && p.arg[optlen] == '=' {
		*val = p.arg[optlen+1:]
		return true
	}

	// If this is of the form --opt val, and there are more args, then
	// the next arg is the value
	if p.arg == opt && p.pos < len(p.args) {
		*val = p.args[p.pos]
		p.pos += 1
		return true
	}

	// Otherwise, we failed to parse this.
	return false
}

// IntArg auto-creates usage and checks the current arg against a
// specific integer option.
func (p *CmdParser) IntArg(opt string, val *int, tag string) bool {
	var strval string
	if !p.StrArg(opt, &strval, tag) {
		return false
	}

	// TBD - if there's an error parsing an integer, we should return
	// some helpful status to the caller
	n, err := strconv.Atoi(strval)
	if err != nil {
		return false
	}
	*val = n
	return true
}

// StrListArg adds a string to the indicated string slice, as well as
// auto-creating usage
func (p *CmdParser) StrListArg(opt string, val *[]string, tag string) bool {
	p.u.MakeUsage(opt, tag, uintptr(unsafe.Pointer(val)))

	// If this is not an option, then it's a positional argument.
	// A string-list takes all remaining positional arguments.
	if opt[0] != '-' && p.arg[0] != '-' {
		*val = append(*val, p.arg)
		return true
	}

	// If this is of the form --opt=val, then get the value from arg
	optlen := len(opt)
	if len(p.arg) > optlen && p.arg[:optlen] == opt && p.arg[optlen] == '=' {
		*val = append(*val, p.arg[optlen+1:])
		return true
	}

	// If this is of the form --opt val, and there are more args, then
	// the next arg is the value
	if p.arg == opt && p.pos < len(p.args) {
		*val = append(*val, p.args[p.pos])
		p.pos += 1
		return true
	}

	// Otherwise, we failed to parse this.
	return false
}

// DateArg parses a string as a date, as well as auto-creating usage.
func (p *CmdParser) DateArg(opt string, val *time.Time, tag string) bool {
	var strval string
	if !p.StrArg(opt, &strval, tag) {
		return false
	}

	t, err := parseDateString(strval)
	if err != nil {
		return false
	}
	*val = t
	return true
}

func parseDateString(s string) (time.Time, error) {
	var formats = []string{
		"2006-01-02 15:04:05 -0700",
		"2006-01-02 15:04:05",
		"2006-01-02",
		"2006",
	} // Mon Jan 2 15:04:05 -0700 MST 2006

	for _, format := range formats {
		t, err := time.Parse(format, s)
		if err == nil {
			return t, nil
		}
	}

	// TBD - if there's an error parsing an integer, we should return
	// some helpful status to the caller instaead of just a fatal here.
	log.Fatalf("Invalid date format: %s\n", s)
	return time.Time{}, nil
}

// ----------------------------------------------------------------------------------------------

// We build command usage as we parse the command-line against the
// user callback. We capture, in order, the options and their associated
// values, and then can use it for Usage (and Help at some point)

type CommandUsage struct {
	usage   []CommandOptionUsage
	targets map[uintptr]int
	seen    map[string]bool
}

type CommandOptionUsage struct {
	opt []string
	tag string
	seen bool
}

func NewCommandUsage() *CommandUsage {
	u := &CommandUsage{}
	u.seen = make(map[string]bool)
	u.targets = make(map[uintptr]int)
	return u
}

// MakeUsage synthesizes usage entry for a command-line option.
// Aliases of the same logical option are gathered together.
// For bool options, pass tag="bool"
func (u *CommandUsage) MakeUsage(opt string, tag string, pval uintptr) {
	// If we've already seen the opt, then we already did the work
	if _, ok := u.seen[opt]; ok {
		return
	}

	// If we haven't seen the target, add a new usage record
	if _, ok := u.targets[pval]; !ok {
		u.targets[pval] = len(u.usage)
		u.usage = append(u.usage, CommandOptionUsage{})
	}

	// Add this specific option's information to usage
	u.seen[opt] = true
	n := u.targets[pval]
	u.usage[n].opt = append(u.usage[n].opt, opt)
	u.usage[n].tag = tag
}

// Seen marks the entry as having been used on the command-line.
// This is done by storage address, to handle aliases of commands.
func (u *CommandUsage) Seen(pval uintptr) {
	u.usage[u.targets[pval]].seen = true
}

func (u *CommandUsage) WasSeen(pval uintptr) bool {
	return u.usage[u.targets[pval]].seen
}

// Usage shows short command-line usage and then exits.
// It groups aliases together, and shows output in the order
// that the command-line was defined by the programmer.
func (u *CommandUsage) Usage(usagePrompt string) string {
	usageLen := len(usagePrompt)
	var output string
	line := usagePrompt
	for _, v := range u.usage {
		var opt string = strings.Join(v.opt, " | ")
		var kv string
		if v.tag == "bool" {
			kv = fmt.Sprintf("[%s]", opt)
		} else {
			kv = fmt.Sprintf("[%s=<%s>]", opt, v.tag)
		}
		if len(line)+1+len(kv) >= 75 {
			output = output + line + "\n"
			line = strings.Repeat(" ", usageLen)
		}
		line = line + " " + kv
	}

	output = output + line
	return output
}
